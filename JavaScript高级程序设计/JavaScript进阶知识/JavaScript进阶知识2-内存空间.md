## JavaScript之内存空间

#### 1. 内存中有栈和堆
 
1）基本类型保存在栈内存中，这些类型在内存中分别占有固定大小的空间，通过按值来访问；<br />

> 基本类型一共6种：Undefined、Null、Boolean、Number、String、Symbol


2）引用类型保存在堆内存中，值的大小不固定，但内存地址大小固定，所以值保存在堆内存中，栈内存只存放该对象的访问地址。==查询引用类型变量时，先从栈中读取内存地址，再通过地址找到堆中的值==。<br/>

3）栈比堆的运算速度快，数组和对象放到堆中是为了不影响栈的效率。引用的方式是查找到堆中的实际对象再进行操作。<br/>

4）池（一般也会归到栈中），用于存放常量，也称常量池。
<br/>

#### 2.内存空间管理
Javascript的内存生命周期是:<br/>
1）分配所需要的内存<br/>
2）使用分配到的内存（读、写）<br/>
3）不需要时将其释放、归还
 
> JavaScript有自动垃圾收集机制。最常用的是通过标记清除的算法来找到哪些对象是不在继续使用的。使用a=null做了一个释放引用的操作，让a原本对应的值失去引用，脱离执行环境，这个值会在下一次垃圾收集器执行操作时被找到并释放。

> 在局部作用域中，当函数执行完毕时局部变量也没有存在的必要了，因此可以很容易判断并回收。但全局变量的判断则很困难。所以尽量避免使用全局变量。
 
 
```
var a = {n: 1};
var b = a;
a.x = a = {n: 2};
 
//此时a的值为{n: 2}, b为{n:1, x: {n: 2}}
a.x     // 这时 a.x 的值是多少 - undefined
b.x     // 这时 b.x 的值是多少 - {n: 2}
```

 
 
闭包中的变量并不保存在栈内存中，而是保存在堆内存中。

```
function A() {
  let a = 1
  function B() {
      console.log(a)
  }
  return B
}
```

==闭包：函数A返回了一个函数B，并且函数B中使用了函数A的变量，函数B就称为闭包。==

> 函数A弹出调用栈后，函数A中的变量此时存储在堆上，所以函数B依旧能引用到函数A中的变量
<br/>

#### 3.内存回收
Javascript有垃圾自动收集机制，每隔固定时间执行一次释放操作，释放不再继续使用的值的内存。
- 局部变量：函数执行完毕后回收
- 全局变量：全局变量很难判断，尽量避免使用。Google的V8引擎中所有的JS对象都是通过堆来进行内存分配的
- 初始分配：当声明变量并赋值时，V8引擎就会在堆内存中分配给这个变量
- 继续申请：当已经申请的内存不足以存储这个变量时，V8引擎就会继续申请内存，直到堆的大小达到了V8引擎的内存上限为止
V8引擎对堆内存中的JS对象进行分代管理
- 新生代：存活周期较短的JS对象，如临时变量、字符串等
- 老生代：经过多次垃圾回收仍然存活，存活周期较长的对象，如主控制器、服务器对象等
<br/>

#### 4.垃圾回收算法
1）引用计数（不再使用）- 看一个对象是否有指向它的引用，没有则回收
> 但循环引用时不会进行回收，如两个对象相互引用但不再使用，也不会对其进行回收，最后可能导致内存泄漏，现代浏览器不再使用该方法
 

```
var div = document.createElement("div");
div.onclick = function() {
    console.log("click");
};
```

> div有事件处理函数的引用，同时事件处理函数也有div的引用，div变量可在函数内被访问，循环引用就出现了。
 
2）标记清除（Mark-and-sweep 常用）- 不再使用的对象定义为无法到达的对象。定时扫描内存中的对象，能从根部到达的保留，否则进行回收
 

```
对于现在的主流浏览器，只需要切断需要回收的对象和根部的联系即可。一般的内存泄漏也都和DOM元素绑定有关：
email.message = document.createElement(“div”);
displayList.appendChild(email.message);
 
// 稍后从displayList中清除DOM元素
displayList.removeAllChildren();
```

 
#### 5.内存泄漏
对于持续运行的服务进程，必须及时释放不再用到的内存。否则内存占用越来越高，轻则影响系统性能，重则导致进程崩溃。对于不再用到的内存没有及时释放，就叫做内存泄漏（memory leak）.
 
##### 识别方法
###### 1）浏览器
打开开发者工具，选择 Memory
在右侧的Select profiling type字段里面勾选 timeline
点击左上角的录制按钮。
在页面上进行各种操作，模拟用户的使用情况。
一段时间后，点击左上角的 stop 按钮，面板上就会显示这段时间的内存占用情况。
 
###### 2）命令行 - Node提供的process.memoryUsage

```
console.log(process.memoryUsage());
{ 
  rss: 27709440,        // resident set size，所有内存占用，包括指令区和堆栈
  heapTotal: 5685248,   // "堆"占用的内存，包括用到的和没用到的
  heapUsed: 3449392,    // 用到的堆的部分,以该字段为准
  external: 8772         // V8 引擎内部的 C++ 对象占用的内存
}
```

 
#### 6.WeakMap

ES6新出的WeakSet & WeakMap是弱引用，它们对于值的引用不计入垃圾回收机制

```
const wm = new WeakMap()
const element = document.getElementById('example')
wm.set(element, 'some informantion')
wm.get(element) //'some information'
```

 

#### 7.四种常见的JS内存泄漏
1）意外的全局变量<br/>
2）被遗忘的计时器或回调函数<br/>
3）脱离DOM的引用<br/>
4）闭包<br/>